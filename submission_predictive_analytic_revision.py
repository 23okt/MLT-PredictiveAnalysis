# -*- coding: utf-8 -*-
"""Submission Predictive Analytic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D9kaNqelOte-ecKNJTAcvJFuu3mpYK6R

## **Project Prediksi Tarif Taxi**

Nama : Muhammad Gilang Ramadhan

- Rincian Project

Tujuan utama dari proyek ini adalah untuk membangun model predictive analytics yang dapat memprediksi tarif taksi berdasarkan berbagai faktor yang mempengaruhi harga perjalanan. Dataset yang digunakan berasal dari platform Kaggle, yang mencakup informasi terkait perjalanan taksi, seperti jarak perjalanan, waktu perjalanan, kondisi lalu lintas, cuaca, jumlah penumpang, dan tarif dasar taksi.

Melalui analisis data yang mendalam, model ini diharapkan dapat mengenali pola-pola yang ada dalam data, sehingga dapat memprediksi tarif taksi secara akurat. Fitur-fitur penting yang akan digunakan dalam model ini meliputi Trip Distance (Jarak Perjalanan), Traffic Conditions (Kondisi Lalu Lintas), Weather (Cuaca), Passenger Count (Jumlah Penumpang), dan Base Fare (Tarif Dasar).

Pada akhir proyek, tujuan utamanya adalah menghasilkan model yang dapat digunakan oleh pihak taksi atau aplikasi ride-hailing untuk menghitung tarif perjalanan secara otomatis, memberikan estimasi biaya yang akurat kepada penumpang berdasarkan kondisi nyata di lapangan. Model ini diharapkan dapat meningkatkan efisiensi dalam perencanaan tarif perjalanan dan membantu pengguna atau operator taksi untuk lebih memahami faktor-faktor yang memengaruhi harga perjalanan.

## Import Library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files
from sklearn.preprocessing import OneHotEncoder
from sklearn.decomposition import PCA
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error

"""## Data Loading"""

files.upload()

df = pd.read_csv('/content/taxi_trip_pricing.csv')
df

"""1.   Dataset ini diambil dari salah satu platform dataset terkenal yaitu kaggle
2.   Dataset ini membuat beberapa fitur seperti Trip Distance(KM),Time of Day,Day of Week, Passenger Count, Traffic Conditions, Weather, Base Fare, Per Km Rate, Per Minute Rate,	Trip Duration Minutes, Trip Price
3. Fitur Trip Price ini akan menjadi target

## Exploratory Data Analysis
"""

df.head()

df.info()

"""1.   Dataset ini terdiri dari 7 fitur dengan data numerik (float)
2.   Dan tersedia juga 4 fitur dengan data kategorikal (object)
3.   Total dari keselurahan fitur yang tersedia pada dataset ini adalah 11 fitur

jumlah data yang tidak kosong ratarata pada setiap fitur 950 namun pada trip price terdapat 951 data yang tidak kosong sedangkan pada awal dataset ini memiliki 1000 jumlah data yang artinya setiap fitur disini memiliki nilai null atau kosong (NaN)


"""

df.describe()

"""1.   Pada fitur trip distance ratarata jarak perjalanan yang ditempuh sekitar 25,83 km dengan jarak perjalanan paling jauh di 146,06 km
2.   Pada fitur passenger count atau jumlah penumpang ini memiliki ratarata 2 penumpang pada setiap perjalanannya dan penumpang tertinggi dalam perjalanannya terdapat 4
3.   Biaya awal pada fitur Base Fare yang tertera memiliki nilai ratarata \$3.52 dan paling tinggi dengan \$5.00
4.  Dan selanjutanya ada biaya Per KM Rate atau biaya berdasarkan Kilometer yang memiliki nilai  rata rata \$1.22 dan paling tinggi dengan \$2.00
5.  Setelah biaya per KM adapaun biaya per Menit dengan nilai ratarata
\$0.29 dan paling tinggi di angka \$0.50
6. Durasi Perjalanan berdasarkan Menit memiliki ratarata dengan 61.8 Menit dan tertinggi dengan 119.8 menit pada perjalanannya
7. Pada fitur harga perjalanannya memiliki ratarata \$50.07 dan harga dengan perjalanan paling tinggi di angka \$332.04

## EDA - Univariate Analysis
"""

cols_categorical = df.select_dtypes(include=['object']).columns
for feature in cols_categorical:
    count = df[feature].value_counts()
    percent = 100 * df[feature].value_counts(normalize=True)

    summary_df = pd.DataFrame({'Jumlah Sampel': count, 'Persentase (%)': percent.round(1)})
    print(f"\n===== {feature} =====")
    print(summary_df)

    plt.figure(figsize=(6, 4))
    count.plot(kind='bar', title=feature)
    plt.ylabel('Jumlah')
    plt.xlabel(feature)
    plt.xticks(rotation=45)
    plt.show()

df.hist(bins=50, figsize=(20,15))
plt.show()

"""*   Trip_Distance_km: Distribusi ini terlihat sangat peaked (puncak tajam) di sekitar nilai 0-50 km.
*   Passenger_Count: Ada frekuensi yang sangat tinggi untuk perjalanan dengan 1 penumpang, diikuti oleh 2 penumpang. Jumlah perjalanan dengan 3 dan 4 penumpang juga signifikan.
*   Base_Fare: Distribusi base fare juga terlihat memiliki puncak yang cukup jelas di sekitar nilai 3-4.
*   Per_Km_Rate: Histogram ini menunjukkan distribusi tarif per kilometer. Sebagian besar nilai terkumpul di rentang sekitar 0.6 hingga 1.8.
*   Per_Minute_Rate: Distribusi tarif per menit terlihat memiliki beberapa puncak, terutama di sekitar nilai 0.15, 0.30, dan 0.40.
*   Trip_Duration_Minutes: Mirip dengan "Trip_Distance_km" dan "Base_Fare", distribusi durasi perjalanan juga memiliki puncak yang jelas di sekitar nilai 50 menit.
*   Trip_Price: Distribusi harga total perjalanan ("Trip_Price") memiliki puncak yang cukup lebar di sekitar nilai 40-60. namun untuk puncaknya di sekitar 50.

# EDA - Multivariate Analysis
"""

for col in cols_categorical:
  sns.catplot(x=col, y="Trip_Price", kind="bar", dodge=False, height=4, aspect = 3, data=df, palette="Set2")
  plt.title("Rata rata 'price' Relatif terhadap - {}".format(col))

"""1.   Dilihat dari ke empat hasil barplot ini bisa dibilang untuk fitur kategorikal tidak ada satupun fitur yang mempengaruhi target (Trip_Price) karena dari ke empat fitur ini menunjukkan hasil yang sama tidak ada yang berbeda dan tidak ada fitur yang relatif ke fitur target (Trip_Price)"""

sns.pairplot(df, diag_kind='kde')

cols_numeric = df.select_dtypes(include=['float64']).columns
plt.figure(figsize=(10, 8))
correlation_matrix = df[cols_numeric].corr().round(2)

sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title("Correlation Matrix untuk Fitur Numerik", size=20)
plt.show()

"""1.   Dilihat dari correlation matrix dan pairplot dengan jelas fitur target Trip_Price sangat berpengaruh ke Trip Distance KM dengan kedekatan (0.85)
2.   Fitur Per KM Rate juga sedikit berpengaruh dengan nilai kedekatan 0.28
3.   Fitur Per Minute Rate ikut berpengaruh dengan nilai kedekatan hingga 0.14
4.   Fitur Trip Duration Minutes memiliki kedekatan yang lumayan dengan fitur target sebesar 0.22


"""

df.head()

"""# Data Preparation

## Menangani Missing Values
"""

data_kosong = df.isnull().sum()
data_duplikasi = df.duplicated().sum()

print(data_kosong)
print("===============================")
print(f"Data yang terindikasi duplikasi: {data_duplikasi}")

"""*   Seperti indikasi yang telah disampaikan di awal dataset ini memiliki nilai kosong sebanyak 50 pada setiap fiturnya namun pada fitur trip_price hanya terdapat 49 nilai yang kosong


"""

df[cols_numeric] = df[cols_numeric].fillna(df[cols_numeric].mean())

data_bersih = cols_numeric.isnull().sum()
print(f"Data kotor pada fitur numeric berjumlah: {data_bersih}")
print("========================================")
print(f"Data memiliki shape: {df.shape}")

"""*   Pada cell ini dilakukan pembersihan data kotor pada kolom numeric dengan menambahkan nilai ratarata pada nilai yang kosong di tiap fitur tahap ini dilakukan agar data yang telah diperoleh masih dapat dilakukan untuk tahap selanjutnya


"""

df[cols_categorical] = df[cols_categorical].fillna(df[cols_categorical].mode().iloc[0])

data_bersih = cols_categorical.isnull().sum()
print(f"Data kotor pada fitur categorical berjumlah: {data_bersih}")

"""*   Pada tahap ini dilakukan pembersihan data kotor yang diisi dengan nilai modus atau nilai yang paling sering muncul pada fitur kategorikal tahap ini dimaksud untuk mempertahankan jumlah data yang telah diperoleh diawal

## Menangani Outliers
"""

for col in cols_numeric:
  plt.figure(figsize=(10,4))
  sns.boxplot(data=df, x=col)
  plt.title(f'Boxplot {col}')
  plt.xlabel(col)
  plt.show()

"""*   Setelah tahap pembersihan data kita beranjak ke tahap pengecekan outliers atau data yang jauh dari kebanyakan data yang ada dalam dataset




"""

cols_numeric = df.select_dtypes(include=['float64'])
Q1 = cols_numeric.quantile(0.25)
Q3 = cols_numeric.quantile(0.75)
IQR = Q3 - Q1

df = df[~((cols_numeric < (Q1 - 1.5 * IQR)) | (cols_numeric > (Q3 + 1.5 * IQR))).any(axis=1)]
df.shape

df = pd.get_dummies(df, columns=cols_categorical, prefix=cols_categorical)
df

X = df.drop(['Trip_Price'], axis=1)
y = df['Trip_Price']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=64)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
X_scaled_df = pd.DataFrame(X_scaled, columns=X.columns)
X_scaled_df.head()

"""# Model Development"""

models = pd.DataFrame(index=['train_mse', 'test_mse'],
                      columns=['RandomForest','XGBRegressor','LinearRegression', 'SVR'])

"""# Model Development dengan RandomForestRegressor"""

RF = RandomForestRegressor(n_estimators=100, max_depth=10, min_samples_split=10, min_samples_leaf=5, random_state=64, n_jobs=-1)
RF.fit(X_train, y_train)
models.loc['train_mse','RandomForest'] = mean_squared_error(y_pred = RF.predict(X_train), y_true=y_train)

"""# Model Development dengan XGBRegressor"""

xgbRegressor = XGBRegressor(n_estimators=20, max_depth=3, random_state=64, n_jobs=-1)
xgbRegressor.fit(X_train, y_train)
models.loc['train_mse','XGBRegressor'] = mean_squared_error(y_pred = xgbRegressor.predict(X_train), y_true=y_train)

"""# Model Development dengan Linear Regression"""

lr_model = LinearRegression()
lr_model.fit(X_train, y_train)
models.loc['train_mse','LinearRegression'] = mean_squared_error(y_pred = lr_model.predict(X_train), y_true=y_train)

"""# Model Development dengan SVR"""

svr_model = SVR(kernel='linear', C=200, epsilon=0.1)
svr_model.fit(X_train, y_train)
models.loc['train_mse','SVR'] = mean_squared_error(y_pred = svr_model.predict(X_train), y_true=y_train)

"""# Evaluasi Model"""

mse = pd.DataFrame(columns=['train','test'], index=['RF','XGBRegressor','LinearRegression','SVR'])

model_dict={'RF': RF, 'XGBRegressor': xgbRegressor, 'LinearRegression': lr_model, 'SVR':svr_model}

for name, model in model_dict.items():
  mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3
  mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3

mse

"""1.   Untuk Model pertama yaitu RandomForestRegressor menyatakan bahwa loss dari trainnya cukup kecil di angka 0.039 namun sayangnya loss dari test sangat berbanding terbalik sangat besar di angka 0.062
2.   Lalu untuk model XGBRegressor memiliki nilai loss pada train di angka 0.046 dan nilai loss pada test di angka 0.055 yang bisa dibilang model ini ideal dan cocok untuk diterapkan
3.  Sedangkan untuk Linear Regression ini memiliki nilai loss pada train di angka 0.099 dimana angka ini sangat besar dan loss pada test adalah 0.070 angka yang sangat besar dan tidak ideal untuk diterapkan
4.  Terakhir untuk SVR ini memiliki nilai loss train paling tinggi di angka 0.100 dan nilai loss pada test rendah sekitar 0.069 sangat disayangkan karena nilai loss train tinggi model ini tidak ideal untuk diterapkan


"""

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""# Inference"""

prediksi = X_test.iloc[:1].copy()
pred_dict = {'y_true':y_test[:1]}
for name, model in model_dict.items():
  pred_dict['predict_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)

"""1.   Dapat dilihat pada hasil prediksi diatas y_true menunjukkan harga aslinya
2.   Model dari RF memprediksi harga dengan hasil \$26.5 hasil ini lumayan dekat dengan nilai aslinya
3.   Model dari XGBRegressor memprediksi harga dengan hasil \$23.5 hasil ini sangat amat mendekati nilai aslinya maka dari itu model ini ideal untuk project kali ini
4.   Model LinearRegression memprediksi harga dengan hasil \$31.8 yang bilang dibilang paling jauh dari harga aslinya
5.   Terakhir pada prediksi dengan model SVR mendapatkan hasil \$31.4 namun hasil ini masih jauh dari hasil aslinya


"""

